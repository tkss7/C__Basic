●포인터 자료형 (자료형이 다르다는것은 저장할 주소의 대상이 다르다)

  - 포인터변수  - 변수의 시작주소 이거나 또는 1차원 배열의 시작주소가 대상 , 변수에 시작주소를 저장하는것이 포인터변수
  - 배열 포인터 - 다차원 배열의 시작 주소를 저장(하나만 저장가능)하여 데이터로 사용하는 보인터 변수
                        ++할때마다 열의 갯수만큼 증가한다 / 2,3차원 이상의 배열 
	         선언형식 -> 자료형 (*변수명)[변수크기(열)]      
			ex) int(*p2)[5] / 2차원 배열포인터, 2차원 정수형 배열 중에서 열의 크기가 5열인 배열의 시작주소가 대상
			ex) int(*p2)[5][6] / 3차원배열포인터, 3차원 정수형 배열 중에서 행열의 크기가 5행6열인 배열의 시작주소가 대상
  - 포인터 배열  - 메모리 주소들을 모아놓은 구조 (주소만 들어온다, 주소 값들을 저장하는 배열) => 주소가 있다는것은 데이터가 있다는 것이다
                        무엇이 할당될지는 알수 없다.
                       선언형식 -> 자료형 *변수명[변수크기(열)]

   ※명령어 라인인수 : 명령 프롬프트에서 실행파일 뒤에 쓰는 인수리스트 / 명령 프롬프트: 명령을 기다리는 상태 -> 공백마다 문자열로 저장
	                 c:\> ch13.exe sample 100 => sample 100 는 인자리스트
                              
		    main(int argc, char *argv[])
                               argc : 명령어 라인 인자의 수
                               argv : 문자열의 주소 저장(포인터배열)

                               C:\ ../source ../repos ../data.txt ../date2.txt    => 상대경로
                               C:\ \source \repos data.txt date2.txt    => 절대경로

  - 다중 포인터 : 포인터변수의 시작주소를 저장한다.      ex) 포인터변수의 시작주소값이 3000인데 이후에 2000의 값을 대입했다. 다중포인터로 해당 포인터변수를 저장하면 시작주소인 3000값이 저장된다.
	         선언형식 -> 자료형 **변수명    
	                          ※ **를 이중포인터라고 한다     
  - 함수 포인터(함수포인터 변수) :  함수를 부를수 있는 포인터  ex) 엑셀 함수마법사 생각하면 된다
	         선언형식 -> 자료형 (*변수명)(매개변수 리스트)   => 변수명은 내맘대로    ex)   int (*fp1)(int, int)
                                                                       ㄴ> 변수명 선언해도 되긴하는데 안해도됨 틀리지 않음, 선언문에서는 변수명 생략가능
	          ※ 함수들도 주소가 있다

	          ① typedef int (*FP)(int, int);   => 함수포인터 자료형 선언, 함수포인터를 typedef로 선언하면 함수포인터 변수가 아닌 함수포인터 자료형이 된다.

                       ②함수포인터 변수를 사용하여 sub함수 호출 방법
	                ex)  int (*fp1)(int, int);
		        fp1 = sub;
		        ret = (*fp1)(100, 30);
	                     printf("sub(): %d \n", ret);

                        ③재정의된 함수포인터 자료형으로 함수포인터 변수선언
		   ex) FP fp2;
		        FP fp3;

                                   fp2 = add;
		        fp3 = sub;

		        printf("add() : %d \n", (*fp2)(200, 30));
            		        printf("sub() : %d \n", (*fp3)(200, 30));

	           ④재정의된 함수포인터 자료형으로 함수포인터 배열선언
	                 ex) FP fp4[5]; //함수포인터 배열
		        fp4[0] = add;
		        fp4[1] = sub;

  	                      printf("add() : %d \n", (*fp4[0])(300, 30));
		        printf("sub() : %d \n", (*fp4[1])(300, 30));

	           ⑤ 함수를 호출할 때 함수 주소를 실인수로 전달  -> 함수의 주소가 실인수로 들어올때 반드시 함수포인터 필요
	                  ex) void funcCacl(int(*fp5)(int , int ))         =>메인함수 밖에 선행 필요 -> 간단하게 만들시 void funcCacl(FP fp5)
		   	{
			printf("funCalc() : %d \n", (*fp5)(400, 30));
			}   


 		          funcCacl(add);
	                       funcCacl(sub);

  - void형 포인터


 : 포인터 변수에 저장할 메모리의 주소가 타입(대상)이 다르다
  ①포인터 선언문
  ②주소를 가져오는 방법
  ③주소를 사용하는 방법





조작 및 사용하려면 주소를 받아햐함
주소를 받는걸 call by reference
엑세스를 하면 출력도 가능하지만...?
 