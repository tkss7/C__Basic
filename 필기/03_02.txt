CH01 ~ 03
Visual Studio
*MS사는 컴파일을 빌드라고부름*
1. 빌드 : ctrl + B
2.디버깅 하지 않고 시작 : ctrl +F5
3. 주석처리 : ctrl + shift + /

자료형과 인자리스트는 생략 가능

if 현재 안쓰는 . c파일 제외하고 싶으면 :
.c 파일 우클릭 -> 속성 -> 빌드에서 제외 : 예
else
.c 파일 우클릭 -> 속성 -> 빌드에서 제외 : 아니오

sizeof() == 할당받은 메모리의 크기를 반환
ex)
float PI = 3.14159F ==> 4바이트 크기로 변환해서 넣어라.라는 뜻

swap out : 가상메모리에 내림
swap in : 가상메모리에서 꺼냄
두개를 합쳐서 스와핑이라고 함

메모리에 할당되는 모든것은 주소로 관리된다.
메모리에 저장할때는 무조건 &를 사용해야 한다.

표준라이브러리 사용할땐 프로젝트 속성 -> [C/C++] -> [일반] 에 [SDL검사] 를 아니오로 표시

주소의 번지 == 1번지당 1바이트?
%p , & : 해당 변수의 시작주소의 번지수를 반환함
%f : float형 출력
%lf : double형 출력  l ==> 소문자 엘
%를 문자로 쓰고 싶을땐 %%를 쓰면 됨

메모리는 재활용(쓰레기)
누적형 변수는 초기화 안할 시 쓰레기 값이 저장되에 원하는 값이 안나올 수있다.
기호상수 : 값을 못바꾸게 할 수 있는 상수
매크로상수 = 전역변수(프로그램의 어디에서나 쓸 수 있음)
const => 변수를 상수화 시켜서 값이 안바뀌게 함

short ==> %hd
long ==> %ld

signed : 맨 앞 비트를 0: 양수 , 1: 음수로 정하는 용도로 쓰는 것
signed char : -128~127
unsigned char : 0~255
unsigned int ==> %u
32비트 운영체제의 경우 
8byte 정수형 = long long int or __int64

유효자릿수(정밀도)

float : 4byte : 6자리 까지 보장 == 큰수를 저장가능하나 정밀도가 떨어짐
double : 8byte : 15자리 까지 보장 == 

형변환
int a =100;
(float)a ==> 100.0

컴퓨터가 알아서 바꾸면 묵시적 형변환
수식을 처리할 때 두 피연산자 중 큰 피연산자 형으로 나머지 자료형을 자동 형변환하는것
 ex) float / int 면 float의 형이 더 크므로 뒤의 int가 float으로 바뀌어 처리됨

사용자가 바꾸는거면 명시적 형변환

받고자하는 변수는 주고자 하는 변수의 값보다 같거나 커야한다.

음수의 표현 
_> 2의 보수 처리함



typedef unsigned long int U_int;  ==> unsigned long int 를 U_int로 정의함
==> 기존에 있는 자료형을 간단하게 표현하고 싶을때 사용함


나열형 상수
보는건 문자로 보고 쓰는건 정수형 상수로 쓰고 싶을때 쓴다
myColor 쓰는경우 : Color에 있는 값만 쓰고싶을때 씀


솔루션 안에 프로젝트를 포함함
하나의 솔루션안에 프로젝트를 여러개 갖을 수 있음
실행단위는 프로젝트 단위로 실행됨
프로젝트명 중에 굵은 글씨 처리가 된게 시작 프로젝트임

-------------------------------------------------------------------------------------------------------------
CH04
Stream : 프로세스와 외부장치간의 논리적인 연결
표준 스트림 : O/S 제공
stdin : 키보드
stdout : 터미널
stderr : 터미널


C프로세스 : 키보드와 터미널 둘다 사용(제공되는 라이브러리 함수를 사용하면 됨)
printf scanf
putchar getchar
puts gets 

printf, putchar, puts ->출력함수(터미널)
scanf, getchar, gets -> 입력함수(키보드)  ==> 라인버퍼 입력함수 라고 부름(엔터를 쳐야함 넘어감)

putchar를 사용하는 이유 == 많은양의 반복적인 문자열 디스플레이를 사용할때 조금 더 간편해짐
puts ==> 자동으로 줄바꿈기능 사용됨



%#을 쓰면 형식을 디스플레이 해줌!!!!
%o =8진수 
\t ==> tab 한것

\n ==> CR + LF  13 + 10 ==> %c%c ==>13,10

-------------------------------------------------------------- 중요?--

flush(stdin); 괄호안에 있는 내용을 비워라 stdin == 입력버퍼
while (getchar() != '\n'); //입력버퍼의 내용을 하나씩 꺼내서 사실상 버린다.


scanf구분 == tab, enter, space로 구분함

%*c ==> 문자를 버림
%c ==> 문자를 읽음

입출력은 CPU에 직접받는게 아니라 버퍼를 이용한다.

input n1 ? 100[enter]
input ch ?
input n2 ? 200[enter[
%d, %f 형태들의 scanf는 사전에 있던 입력 버퍼의 enter같은 줄,칸 바꿈을 버려준다.

따라서 scanf에서 %f 뒤에 %*c를 쓰는 이유가 입력버퍼에 있는 enter를 버려주어 오류를 방지하기 때문임
and 
	scanf(" %c", &ch);  //공백 지정자 : 입력버퍼의 공백, [enter], [tab]을 버린다. ==> " %c"

원래 %c는 공백을 받지만 " %c"로 쓰면 공백을 안받을 수 있다.

입력함수의 입력이 잘못들어오면 그 입력이 뒤로밀리면서 (프로세스가 죽는게 아니고 그 밑으로 떨어트림) 다른 입력에 영향을 끼친다.

-------------------------------------------------------------------------------------------------------------------------------------------------

cmd

1. dir :  파일조회
2. cd xxxx형식 : 파일 이동
3. 파일명 대소문자 구분 : fsutil.exe file SetCaseSensitiveInfo D:\CaseTest enable
-> CaseTest 라는 폴더를 만들었다는 가정하에




